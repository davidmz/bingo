package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	var (
		inFileName  string
		outFileName string
		varName     string
		pkgName     string
		showHelp    bool

		err error
	)

	flag.StringVar(&inFileName, "in", "", "Input file or stdin if empty")
	flag.StringVar(&outFileName, "out", "", "Output file or stdout if empty")
	flag.StringVar(&varName, "var", "foo", "Variable name")
	flag.StringVar(&pkgName, "pkg", "main", "Package name")
	flag.BoolVar(&showHelp, "help", false, "Show help")
	flag.Parse()

	if showHelp {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", filepath.Base(os.Args[0]))
		flag.PrintDefaults()
		os.Exit(1)
	}

	inFile, outFile := os.Stdin, os.Stdout

	if inFileName != "" {
		inFile, err = os.Open(inFileName)
		if err != nil {
			log.Fatalln(err)
		}
		defer inFile.Close()
	}

	if outFileName != "" {
		outFile, err = os.Create(outFileName)
		if err != nil {
			log.Fatalln(err)
		}
		defer outFile.Close()
	}

	result := new(bytes.Buffer)

	fmt.Fprint(result, "// Code generated by github.com/davidmz/bingo. DO NOT EDIT.\n")
	fmt.Fprintf(result, "package %s\n\n", pkgName)
	fmt.Fprintf(result, "var %s = []byte(", varName)
	buf := make([]byte, 24)
	firstLine := true
	for {
		n, err := inFile.Read(buf)
		if n > 0 {
			s := strings.Replace(fmt.Sprintf(`\x% x`, buf[:n]), ` `, `\x`, -1)
			if firstLine {
				firstLine = false
				fmt.Fprintf(result, "\"%s\"", s)
			} else {
				fmt.Fprintf(result, " +\n        \"%s\"", s)
			}
		}
		if err == io.EOF {
			fmt.Fprint(result, ")\n")
			break
		}
		if err != nil {
			log.Fatalln(err)
		}
	}

	formatted, err := format.Source(result.Bytes())
	if err != nil {
		log.Fatalln(err)
	}

	_, err = io.Copy(outFile, bytes.NewReader(formatted))
	if err != nil {
		log.Fatalln(err)
	}
}
